<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>工具 on 卡美桑的家</title>
    <link>https://kamesanblog.github.io/categories/%E5%B7%A5%E5%85%B7/</link>
    <description>Recent content in 工具 on 卡美桑的家</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-tw</language><lastBuildDate>Fri, 12 Dec 2025 00:00:00 +0800</lastBuildDate><atom:link href="https://kamesanblog.github.io/categories/%E5%B7%A5%E5%85%B7/index.xml" rel="self" type="application/rss+xml" /><item>
      <title>我的筆記軟體Obsidian</title>
      <link>https://kamesanblog.github.io/posts/20251212-whyobsidian/</link>
      <pubDate>Fri, 12 Dec 2025 00:00:00 +0800</pubDate><guid>https://kamesanblog.github.io/posts/20251212-whyobsidian/</guid>
      <description>&lt;p&gt;&lt;img loading=&#34;lazy&#34; src=&#34;https://kamesanblog.github.io/posts/20251212-whyobsidian/20251212001.jpg&#34;&gt;&lt;/p&gt;
&lt;p&gt;知道Obsidian 之前，想到要寫日誌就會想到Dayone，想到寫個筆記就會打開手機內的特定軟體比如Evernote或是iPhone內的Notes。&lt;/p&gt;
&lt;p&gt;直到有一天我發現Dayone出了Dayone2！接著宣布Dayone不在更新..我之前一次買斷的Dayone升級成Dayone2&amp;hellip;變成了訂閱制&amp;hellip;. 而Evernote更絕～本來就需要訂閱，但後來取消訂閱之後你的筆記就被降級功能還要重新訂閱才能打開&amp;hellip;.&lt;/p&gt;
&lt;p&gt;那我想到如果使用免費的網路社群平台做日誌或筆記呢？&lt;br&gt;
代價就是交出隱私吧～我將完全無法掌控自己的資料及隱私狀態。另外如果手機太老舊了還要被強迫更新才能繼續使用～～此外，那天一早醒來當我打開社群霉體，卻發些我被盜帳號、或因某些原因被社群平台封鎖帳號刪除&amp;hellip;那大概腦中就會一片空白吧&amp;hellip;.&lt;/p&gt;
&lt;p&gt;什麼時候開始，在自己手機使用這麼簡單的功能都要每月訂閱或連上網路使用社群霉體？常常想著&amp;hellip;或許這是手機及軟體公司聯合替我製造了一個虛擬的農場，而我們是農場裡面的幫他們生產雞蛋賺錢的母雞吧？？&lt;/p&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;哲學家康德說：世界，是被我所認識的世界。&lt;/strong&gt;
&lt;strong&gt;&amp;ldquo;The world as it appears to us is the world as it is structured by our minds.&amp;rdquo;&lt;/strong&gt;
或許同理：&lt;strong&gt;知識，是我所知道的知識。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;直到接觸Obsidian後才瞭解，Obsidian的創辦人Steph Ango應該就是對於上述這樣的困擾而創建出Obsidian。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;免訂閱&lt;/strong&gt;&lt;br&gt;
不用訂閱或註冊即可使用，訂閱只是更方便於各平台的同步。（但除了訂閱還是有很多方式可以達到同步）.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;格式單純&lt;/strong&gt;&lt;br&gt;
Obsidian資料格式就是一個存在超過20年以上的MD格式（Markdown格式：2004年由約翰·格魯伯John Gruber創建）。Steph Ango強調我們所寫下的筆記格式應該是可以長久流傳而不被特定軟體所轉換或開啟的特定格式。（因為我體驗過Evernote還有Dayone轉移格式的痛苦）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;資料隱私與掌控&lt;/strong&gt;&lt;br&gt;
所以你的筆記資料就是你電腦硬碟或是手機內資料夾內部單純的MD檔，沒有特殊格式也不會無緣無故因為網路，社群盜帳號或忘了訂閱而無法使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;知識連結&lt;/strong&gt;&lt;br&gt;
Obsidian的存在只是幫我們管理與連結筆記跟筆記之間的關係。筆記可以透過Obsidian優異的雙向連結功能。讓我們更快速的找到過去所努力過痕跡，因此之前的筆記資料就不易變為散落在硬碟某個角落的孤兒。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現在閱讀時作筆記～坐公車或散步突然腦中有些靈感～或是寫個日誌我都會打開Obsidian，透過簡單又迅速的紀錄優異功能，串連了許多資訊與知識進而變成了一個第二大腦資料庫。或許這才是科技真正的價值所在吧？&lt;/p&gt;
&lt;p&gt;或許我知道的軟體真的不多，也還在持續學習的路上。但真心推薦有閱讀記錄筆記或寫日誌生活紀錄習慣的朋友來嘗試這一個優異的軟體..網路有很多的相關資訊，真的可以嘗試了解看看～&lt;/p&gt;
</description>
    </item><item>
      <title>複習石沈大海的筆記</title>
      <link>https://kamesanblog.github.io/posts/20251014-obsidian-30days-review/</link>
      <pubDate>Tue, 14 Oct 2025 18:53:00 +0800</pubDate><guid>https://kamesanblog.github.io/posts/20251014-obsidian-30days-review/</guid>
      <description>&lt;h3 id=&#34;困擾&#34;&gt;困擾&lt;/h3&gt;
&lt;p&gt;Obsidian使用了半年多之後，發現我好像有很多筆記被遺忘在我的資料庫大海內&amp;hellip;而且我算滿懶惰的，不喜歡去大海撈針&amp;hellip;就算我真的想到有某則筆記，還是需使用查詢功能，其實是很方便沒錯，但我希望資料庫自己提醒我就好，因此又請AI 幫忙了，這個方式對於會寫code的朋友一定會覺得：這樣的基礎，你應該會知道吧？..很可惜我真的不知道&amp;hellip;.
所以我請AI協助我寫出：顯示我的資料庫內超過30天沒動過的筆記，&lt;/p&gt;
&lt;p&gt;下面是我使用的dataview&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-dataview&#34; data-lang=&#34;dataview&#34;&gt;table file.mday as &amp;#34;最後編輯日&amp;#34; , title, description
from &amp;#34;&amp;#34;
WHERE file.mtime &amp;lt; date(today) - dur(30 day)
and contains(file.path, &amp;#34;Template&amp;#34;) = false
and contains(file.path, &amp;#34;Attachment&amp;#34;) = false
and !contains(file.path, &amp;#34;Diary&amp;#34;)
and !contains(file.tags, &amp;#34;Archive&amp;#34;)
sort file.mday asc
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h3 id=&#34;googlegemin解釋&#34;&gt;GoogleGemin解釋&lt;/h3&gt;
&lt;p&gt;它的目的是在你的整個庫中，找出&lt;strong&gt;超過 30 天沒有編輯&lt;/strong&gt;，且&lt;strong&gt;不是&lt;/strong&gt;模板、附件或日記的檔案，並以表格形式列出它們，按照最後編輯日期升序排列。&lt;/p&gt;
&lt;h4 id=&#34;查詢結果格式&#34;&gt;查詢結果格式&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;table file.mday as &amp;quot;最後編輯日&amp;quot; , title, description&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;table&lt;/code&gt;&lt;/strong&gt;: 表示查詢結果將以&lt;strong&gt;表格&lt;/strong&gt;的形式呈現。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;file.mday&lt;/code&gt;&lt;/strong&gt;: 這是檔案的&lt;strong&gt;最後修改日期&lt;/strong&gt;（Modified Day），它代表檔案內容&lt;strong&gt;上次被更改的日期&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;as &amp;quot;最後編輯日&amp;quot;&lt;/code&gt;: 將這個欄位在表格中顯示的標題命名為「最後編輯日」。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;title&lt;/code&gt;&lt;/strong&gt;: 這是檔案的&lt;strong&gt;標題&lt;/strong&gt;（如果檔案中有定義 &lt;code&gt;title&lt;/code&gt; 欄位的話，否則通常是檔案名稱）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;description&lt;/code&gt;&lt;/strong&gt;: 這是檔案的&lt;strong&gt;描述&lt;/strong&gt;（如果檔案中有定義 &lt;code&gt;description&lt;/code&gt; 欄位的話）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;查詢範圍&#34;&gt;查詢範圍&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;from &amp;quot;&amp;quot;&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;from &amp;quot;&amp;quot;&lt;/code&gt;&lt;/strong&gt;: 表示從&lt;strong&gt;整個資料庫&lt;/strong&gt;（Vault）中的所有檔案進行查詢。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;過濾條件-where&#34;&gt;過濾條件 (&lt;code&gt;WHERE&lt;/code&gt;)&lt;/h4&gt;
&lt;p&gt;這些條件用於篩選出符合要求的檔案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;WHERE file.mtime &amp;lt; date(today) - dur(30 day)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;這是&lt;strong&gt;最主要的篩選條件&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;file.mtime&lt;/code&gt;: 檔案的&lt;strong&gt;最後修改時間&lt;/strong&gt;（Modified Time，包含時間資訊）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;date(today)&lt;/code&gt;: 今天的日期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dur(30 day)&lt;/code&gt;: 一個 30 天的時間長度（Duration）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;date(today) - dur(30 day)&lt;/code&gt;: 計算出 &lt;strong&gt;30 天前的日期和時間&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;file.mtime &amp;lt; ...&lt;/code&gt;: 判斷檔案的最後修改時間是否&lt;strong&gt;早於&lt;/strong&gt; 30 天前的時間，即：這個檔案&lt;strong&gt;已經超過 30 天沒有被編輯了&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;and contains(file.path, &amp;quot;Template&amp;quot;) = false&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排除&lt;strong&gt;路徑&lt;/strong&gt;中包含 &lt;code&gt;&amp;quot;Template&amp;quot;&lt;/code&gt; 這個詞的檔案（通常是排除模板檔案）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;and contains(file.path, &amp;quot;Attachment&amp;quot;) = false&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排除&lt;strong&gt;路徑&lt;/strong&gt;中包含 &lt;code&gt;&amp;quot;Attachment&amp;quot;&lt;/code&gt; 這個詞的檔案（通常是排除附件資料夾中的檔案，例如圖片、PDF 等）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;and !contains(file.path, &amp;quot;Diary&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;!&lt;/code&gt; 表示「非」或「不」。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;排除&lt;strong&gt;路徑&lt;/strong&gt;中包含 &lt;code&gt;&amp;quot;Diary&amp;quot;&lt;/code&gt; 這個詞的檔案（通常是排除日記檔案）。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;and !contains(file.tags, &amp;quot;Archive&amp;quot;)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;排除&lt;strong&gt;檔案標籤&lt;/strong&gt;（&lt;code&gt;file.tags&lt;/code&gt;）中包含 &lt;code&gt;&amp;quot;Archive&amp;quot;&lt;/code&gt; 這個標籤的檔案（通常是排除已歸檔的檔案）。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;排序&#34;&gt;排序&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sort file.mday asc&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;sort&lt;/code&gt;&lt;/strong&gt;: 表示排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;file.mday&lt;/code&gt;&lt;/strong&gt;: 按照檔案的最後修改日期來排序。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;asc&lt;/code&gt;&lt;/strong&gt;: 升序（Ascending），表示從&lt;strong&gt;最早&lt;/strong&gt;的日期排到&lt;strong&gt;最近&lt;/strong&gt;的日期。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;補充&#34;&gt;補充&lt;/h3&gt;
&lt;p&gt;我會設定archive 的tag,當作是我覺得這篇筆記不需要再重新覆盤了，就可將筆記標上這個tag. 未來該筆記就不會再度顯示在複習列表內。
另外我也用一個template 做一個rechecked 的簡易表示，讓我知道這個檔案我已經在什麼時候已經複習過，只需要開一個新筆記，將下面的句子貼上後，就可以放在template 資料夾使用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;recheck:{{date}} {{time}} &lt;/code&gt;&lt;/p&gt;
&lt;p&gt;複習範例如圖，如果期間又有新想法也可以加上心得。
或是您也有在複習筆記的好想法，非常歡迎跟我分享，感謝。
&lt;img loading=&#34;lazy&#34; src=&#34;https://kamesanblog.github.io/posts/20251014-obsidian-30days-review/20251014002.jpg&#34;&gt;&lt;/p&gt;
</description>
    </item><item>
      <title>在Obsidian實現Dayone的OnThisDay功能</title>
      <link>https://kamesanblog.github.io/posts/20250927-obsidian-dayone-onthisday/</link>
      <pubDate>Sat, 27 Sep 2025 10:58:00 +0800</pubDate><guid>https://kamesanblog.github.io/posts/20250927-obsidian-dayone-onthisday/</guid>
      <description>&lt;h2 id=&#34;起因&#34;&gt;起因&lt;/h2&gt;
&lt;p&gt;卡美桑個性其實蠻念舊的&amp;hellip;所以有了智慧型手機後就有記錄一些日常的活動，當時購買了Dayone app以爲可以用到天荒地老&amp;hellip;&amp;hellip;但好景不常後來Dayone遇到&lt;a href=&#34;https://wiwi.blog/blog/notebooklm-enshittification&#34;
     rel=&#34;noopener&#34;
     class=&#34;external-link&#34;
     target=&#34;_blank&#34;
 &gt;&lt;strong&gt;你的日記不是你的日記&lt;/strong&gt;&lt;/a&gt;
 之app轉月費制問題，當初一次性購買的我滿腔怒火…但畢竟原來功能都一樣，只是不能有月費制的功能,活像一個閹割版&amp;hellip;.不過畢竟也還是可用，所以也就將就用了&amp;hellip;但從那時候開始我心裡就種下&amp;quot;&lt;strong&gt;總有一天會被軟體綁架不安的種子&lt;/strong&gt;&amp;quot;&lt;/p&gt;
&lt;p&gt;去年因為購買了[電子書閱讀器]，讀到了卡片筆記盒的做筆記方式而接觸到Obsidian，超喜歡Obsidian的簡易Markdown格式，所有的資料都是簡單的md文字檔，真的很便利於管理。&lt;/p&gt;
&lt;p&gt;學習使用Obsidian的過程中，有一天發現，要脫離DayOne軟體綁架的控制，只要把日記搬到Obsidian就可以啦～！超開心！！！
但是卻對於DayOne的一個on this day 功能很懷念&amp;hellip;因為它可以顯示所有你日記裡面跟今天相同日期的所有日記～這樣的功能很適合做一種類似復盤的回憶感～～&lt;/p&gt;
&lt;p&gt;因此開始爬文，可是這樣的資料好像很偏門&amp;hellip;感覺不太多&amp;hellip;苦惱之際突然想到使用AI～～～
老天～～～！整個豁然開朗！AI寫了一堆我看不懂的程式～但是我照著做就可以在我的每個日記md檔內加入 one this day的功能～！！謝謝ＡＩ～&lt;/p&gt;
&lt;h2 id=&#34;使用方法&#34;&gt;使用方法&lt;/h2&gt;
&lt;p&gt;以下我會貼出我目前使用的程式碼，你也可以把程式碼丟給ＡＩ請他解釋作用，這邊下方我會請Google Gemini解釋程式碼，給你做參考看看。&lt;/p&gt;
&lt;p&gt;我使用在日記裡面的程式碼是dataviewjs：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 1. 取得當前檔案的 Diary_time
let current = dv.current().Diary_time;

// 2. 篩選所有檔案，抓出月與日相同的
let results = dv.pages()
  .where(p =&amp;gt; p.Diary_time &amp;amp;&amp;amp; 
              p.Diary_time.month == current.month &amp;amp;&amp;amp; 
              p.Diary_time.day == current.day);

// 3. 輸出表格 (檔案改成連結)
dv.table([&amp;#34;檔案&amp;#34;, &amp;#34;日期&amp;#34;], 
  results.map(p =&amp;gt; [dv.fileLink(p.file.path), p.Diary_time]));
&lt;/code&gt;&lt;/pre&gt;&lt;hr&gt;
&lt;h2 id=&#34;gemini程式碼逐步解釋&#34;&gt;Gemini程式碼逐步解釋&lt;/h2&gt;
&lt;p&gt;這段程式碼是用於 &lt;strong&gt;DataviewJS&lt;/strong&gt; (一種在 Obsidian 筆記軟體中用於查詢和顯示資料的 JavaScript 語言) 的腳本。&lt;/p&gt;
&lt;p&gt;它的核心功能是找出所有筆記中，其 &lt;strong&gt;&lt;code&gt;Diary_time&lt;/code&gt;&lt;/strong&gt; 欄位 (可能是日期或時間) 的 &lt;strong&gt;月份和日期&lt;/strong&gt; 與當前正在瀏覽的筆記的 &lt;strong&gt;&lt;code&gt;Diary_time&lt;/code&gt;&lt;/strong&gt; 欄位的月份和日期完全相同的筆記。簡單來說，它在尋找所有「&lt;strong&gt;歷史上的今天&lt;/strong&gt;」的筆記。&lt;/p&gt;
&lt;h3 id=&#34;1-取得當前檔案的-diary_time&#34;&gt;1. 取得當前檔案的 &lt;code&gt;Diary_time&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;程式碼片段&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 1. 取得當前檔案的 Diary_time
let current = dv.current().Diary_time;
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dv.current()&lt;/code&gt;: 取得當前正在開啟和瀏覽的 Obsidian 檔案的資料。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.Diary_time&lt;/code&gt;: 從當前檔案的 &lt;strong&gt;Frontmatter&lt;/strong&gt; (檔案開頭的 YAML 區塊) 或 &lt;strong&gt;內聯欄位&lt;/strong&gt; 中，取出名為 &lt;code&gt;Diary_time&lt;/code&gt; 的欄位的值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;let current = ...&lt;/code&gt;: 將這個 &lt;code&gt;Diary_time&lt;/code&gt; 的值存入一個名為 &lt;code&gt;current&lt;/code&gt; 的變數中。這個變數代表了我們用來比較的&lt;strong&gt;目標日期&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-篩選所有檔案抓出月與日相同的資料&#34;&gt;2. 篩選所有檔案，抓出月與日相同的資料&lt;/h3&gt;
&lt;p&gt;程式碼片段&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 2. 篩選所有檔案，抓出月與日相同的
let results = dv.pages()
  .where(p =&amp;gt; p.Diary_time &amp;amp;&amp;amp;
              p.Diary_time.month == current.month &amp;amp;&amp;amp;
              p.Diary_time.day == current.day);
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dv.pages()&lt;/code&gt;: 取得 &lt;strong&gt;Obsidian 保管庫中所有筆記&lt;/strong&gt; (檔案) 的集合。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;.where(...)&lt;/code&gt;: 對這個集合進行篩選。括號中的是一個篩選條件，只有符合條件的筆記會被保留。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p&lt;/code&gt;: 代表集合中的每一個筆記。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p.Diary_time &amp;amp;&amp;amp;&lt;/code&gt;: 確保該筆記&lt;strong&gt;有&lt;/strong&gt;一個 &lt;code&gt;Diary_time&lt;/code&gt; 欄位的值 (避免錯誤)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p.Diary_time.month == current.month&lt;/code&gt;: 檢查該筆記的 &lt;code&gt;Diary_time&lt;/code&gt; 的&lt;strong&gt;月份&lt;/strong&gt;是否與當前筆記的 &lt;code&gt;Diary_time&lt;/code&gt; (即 &lt;code&gt;current&lt;/code&gt;) 的&lt;strong&gt;月份&lt;/strong&gt;相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p.Diary_time.day == current.day&lt;/code&gt;: 檢查該筆記的 &lt;code&gt;Diary_time&lt;/code&gt; 的&lt;strong&gt;日期&lt;/strong&gt;是否與當前筆記的 &lt;code&gt;Diary_time&lt;/code&gt; (即 &lt;code&gt;current&lt;/code&gt;) 的&lt;strong&gt;日期&lt;/strong&gt;相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;let results = ...&lt;/code&gt;: 將所有符合「月份和日期都相同」條件的筆記存入 &lt;code&gt;results&lt;/code&gt; 變數中。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-輸出表格-檔案改成連結&#34;&gt;3. 輸出表格 (檔案改成連結)&lt;/h3&gt;
&lt;p&gt;程式碼片段&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;// 3. 輸出表格 (檔案改成連結)
dv.table([&amp;#34;檔案&amp;#34;, &amp;#34;日期&amp;#34;],
  results.map(p =&amp;gt; [dv.fileLink(p.file.path), p.Diary_time]));
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dv.table([...], [...])&lt;/code&gt;: 建立並輸出一個 Dataview 表格。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一個陣列 &lt;code&gt;[&amp;quot;檔案&amp;quot;, &amp;quot;日期&amp;quot;]&lt;/code&gt;: 定義表格的&lt;strong&gt;欄位標題&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二個陣列: 定義表格的&lt;strong&gt;內容&lt;/strong&gt; (每一列的資料)。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;results.map(...)&lt;/code&gt;: 將 &lt;code&gt;results&lt;/code&gt; 集合中的每一個筆記 (&lt;code&gt;p&lt;/code&gt;) 轉換成表格中的&lt;strong&gt;一行資料&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;[dv.fileLink(p.file.path), p.Diary_time]&lt;/code&gt;: 這是每一行資料的兩個欄位的值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;dv.fileLink(p.file.path)&lt;/code&gt;: 將筆記的完整路徑轉換成一個可以在 Obsidian 中點擊的&lt;strong&gt;連結&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;p.Diary_time&lt;/code&gt;: 顯示該筆記的 &lt;code&gt;Diary_time&lt;/code&gt; 的原始值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;接著我還把這樣的功能運用到我的筆記與閱讀復盤&amp;hellip;.整個就是撒花，也讓我離開被DayOne 綁架的日子。（完）&lt;/strong&gt;&lt;/p&gt;
</description>
    </item></channel>
</rss>